<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>MoveMaster | Overview</title>
      <link rel="stylesheet" href="./styles.css">
      <link rel="icon" href="images/mm-icon.png" type="image/x-icon">
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
      <script type="text/javascript" async
  src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script type="text/javascript" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
   </head>
   <body>
      <div class="container">
         <div class="subcontainer">
           <div class="header">
             <img class="mm-icon" src="images/mm-icon.png" />
             <img class="mm-logo" src="images/mm-logo.png" />
             <div class="vertical-line"></div>
             <a href="https://new.rcos.io/projects/movemaster/?semester=202501" class="rcos-button" target="_blank">
               <div class="view-our-project-on">View our Project on</div>
               <img class="rcos-logo" src="images/rcos-logo.png" />
             </a>
             <div class="vertical-line"></div>
             <a href="https://github.com/move-master" class="git-hub-button" target="_blank">
               <div class="view-our-repos-on">View our Repos on</div>
               <img class="git-hub-logo" src="images/git-hub-logo.png" />
             </a>
           </div>
           <div class="contents">
             <div class="sidebar">
               <div class="overview-button unloadButton">Overview</div>
               <div class="u-24">
                 <br />
                 U24
               </div>
               <a class="u-24-mtgm-button unloadButton">Modeling the Game Mathematically</a>
               <a class="u-24-gsvis-button unloadButton">Game-State Visualizer in Scratch</a>
               <a class="u-24-gssv-1-button unloadButton">Game-State Simulator V1 in Unity</a>
               <div class="s-25">
                 <br />
                 S25
               </div>
               <a href="pages/revisiting-our-underlying-representation.html" class="s-25-rour-button">
                 Revisiting our Underlying Representation
               </a>
               <a href="pages/game-sequence-generator-in-python.html" class="s-25-gsgip-button">Game Sequence Generator in Python</a>
               <a href="pages/game-state-simulator-v2-in-unity.html" class="s-25-gssv-2-button">Game-State Simulator V2 in Unity</a>
             </div>
             <div class="content">


              <div class="page" id="overview_page">

               <div class="jenga-subsection">
                 <span>
                   <span class="overview-text-span">
                     Overview
                     <br />
                     <br />
                   </span>
                   <span class="overview-text-span3">
                     Welcome to MoveMaster!
                     <br />
                   </span>
                   <span class="overview-text-span4">
                     Originally an RCOS project, MoveMaster was created with the vision
                     of combining physics simulation and machine learning to determine
                     the most optimal move set for winning various online and tabletop
                     games. By leveraging advanced computational techniques, MoveMaster
                     strives to provide users with strategic recommendations tailored
                     to the selected game.
                   </span>
                 </span>
               </div>
               <div class="jenga-subsection">
                 <div class="overview-text2">
                   <span>
                     <span class="overview-text-2-span">
                       Jenga
                       <br />
                     </span>
                     <span class="overview-text-2-span2">
                       <br />
                     </span>
                     <span class="overview-text-2-span5"> In <a href="https://en.wikipedia.org/wiki/Jenga" class="link" target="_blank">Jenga</a>, players take turns strategically removing pieces from a tower
                       made of 54 wooden blocks, and stacking these pieces on top. The
                       objective of the game is to avoid knocking over the tower.
                       Although this seems like a relatively simple objective, in
                       practice, this proves to be easier said than done.
                       <br />
                       <br />
                       MoveMaster allows users to define the current state of a Jenga
                       game (i.e., the displacement of blocks). Based on the current
                       configuration of the tower, MoveMaster suggests the best
                       possible move to maximize a player&#039;s chances of success.
                       <br />
                       As it currently stands, Jenga is the only tabletop game we have
                       been developing MoveMaster for. However, we are open to
                       exploring other tabletop games in the future.
                       <br />
                     </span>
                   </span>
                 </div>
                 <img class="jenga-tower-cropped" src="images/jenga-tower-cropped.png" />
               </div>
               <div class="jenga-subsection">
                 <div class="overview-text3">
                   <span>
                     <span class="overview-text-3-span">
                       Timeline
                       <br />
                     </span>
                     <span class="overview-text-3-span2">
                       <br />
                       U24
                       <br />
                     </span>
                     <span class="overview-text-3-span3">
                       <br />
                     </span>
                     <span class="overview-text-3-span4">
                       We first started working on MoveMaster in the summer of 2024.
                       Over the course of U24, we achieved the following:
                       <br />
                     </span>
                     <ol class="overview-text-3-span5">
                       <li value="1">
                         Developed a basic conjecture about when blocks are safe vs.
                         unsafe to remove.
                       </li>
                     </ol>
                     <span class="overview-text-3-span6">
                       Because the physical dynamics behind Jenga are extremely tedious
                       to calculate by hand, and it is impossible to simulate all
                       possible tower configurations to determine the outcome of every
                       game state, we decided to come up with a generalized conjecture
                       about when blocks are safe vs. unsafe to remove. Although this
                       required us to greatly simplify the problem at hand (i.e., we
                       ignored stochastic factors like human error, friction between
                       blocks, and non-uniformity among pieces), this conjecture
                       enabled us to begin developing a working model that we would
                       eventually expand to include these factors.
                       <br />
                       To learn more about our conjecture (and our underlying
                       representation of the game as a whole), see <a href="https://www.example.com" class="link" target="_blank">Modeling the Game
                       Mathematically</a>.
                       <br />
                       <br />
                     </span>
                     <ol class="overview-text-3-span7">
                       <li value="2">Developed a primitive game-state visualizer in Scratch.</li>
                     </ol>
                     <span class="overview-text-3-span8">
                       To aid in our discourse surrounding the development of our Unity
                       game-state simulator, we created a very primitive game-state
                       visualizer using Scratch. The visualizer accepts a 54-bit binary
                       sequence of 0s and 1s, and visualizes this sequence as a Jenga
                       tower, where 0s are empty spaces and 1s are blocks.
                       <br />
                       To learn more about our visualizer, see <a href="https://www.example.com" class="link" target="_blank">Game-State Visualizer in
                       Scratch</a>.
                       <br />
                       <br />
                     </span>
                     <ol class="overview-text-3-span9">
                       <li value="3">
                         Developed a physics-based Jenga game-state simulator in Unity.
                       </li>
                     </ol>
                     <span class="overview-text-3-span10">
                       To serve as a basic framework/prototype for our eventual
                       machine-learning program, we created a Jenga game-state
                       simulator that makes use of Unity&#039;s built-in physics
                       engine. This simulator allows a user to remove blocks from the
                       tower, watch the outcome of their configuration in real time (by
                       enabling physics), and save/load various configurations of said
                       tower. Additionally, this simulator acts a slightly more
                       sophisticated version of our initial Scratch game-state
                       visualizer.
                       <br />
                       To learn more about the first version of our game-state
                       simulator, see <a href="https://www.example.com" class="link" target="_blank">Game-State Simulator V1 in Unity</a>.
                       <br />
                     </span>
                     <span class="overview-text-3-span11">
                       <br />
                       S25
                       <br />
                     </span>
                     <span class="overview-text-3-span12">
                       <br />
                     </span>
                     <span class="overview-text-3-span13">
                       In the first half of S25, we have achieved the following:
                       <br />
                     </span>
                     <ol class="overview-text-3-span14">
                       <li value="1">
                         Revised our underlying game-state representation to better
                         adhere to the rules of Jenga.
                       </li>
                     </ol>
                     <span class="overview-text-3-span15">
                       [Placeholder Text]
                       <br />
                       <br />
                     </span>
                     <ol class="overview-text-3-span16">
                       <li value="2">Created a Jenga game sequence generator in Python.</li>
                     </ol>
                     <span class="overview-text-3-span17">
                       [Placeholder Text]
                       <br />
                       <br />
                     </span>
                     <ol class="overview-text-3-span18">
                       <li value="3">
                         Updated our Unity simulator to accept/execute user-inputted
                         game sequences.
                       </li>
                     </ol>
                     <span class="overview-text-3-span19">
                       [Placeholder Text]
                       <br />
                       <br />
                     </span>
                   </span>
                 </div>
               </div>

               </div>






               <div class="page" id="mtgm_page">

                <div class="jenga-subsection">
                  <span>
                    <span class="overview-text-span">
                      Modeling The Game Mathematically
                      <br />
                      <br />
                    </span>
                    <span class="overview-text-span4">
                      In a classic game of Jenga, there are 54 wooden blocks. Assuming we can have less than 54 blocks in play at any point in the game (i.e., assuming we break the official rules of Jenga), this means that there are 2<sup>54</sup> = 18,014,398,509,000,000 (roughly 18 quadrillion) unique configurations of jenga blocks achievable by simply removing pieces from the original tower. In order to differentiate these game states from one another, let’s represent a game configuration as a 54-bit long sequence of binary:<br/>

                      <div class="binary">111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111</div>

                    </span>
                  </span>
                </div>
                <div class="jenga-subsection">
                  <div class="overview-text2">
                      <span class="overview-text-2-span5">
                        In our model, the left-most bits represent the blocks at the very bottom of the tower, and the right-most bits represent the blocks at the very top of the tower. Additionally, “1” bits indicate the presence of a block in that position, while “0” bits indicate the absence of a block. Furthermore, every tribit represents a layer in the Jenga tower, with the bits progressing from furthest from the camera → closest to the camera when being read from left → right. 
                        Since this manner of representing the configuration of a Jenga game is not particularly intuitive, we provide a labeled diagram to the right:                    
                      </span>
                  </div>
                  <img class="jenga-tower-cropped" src="images/jenga-tower-labeled.png" />
                </div>
                <div class="jenga-subsection">
                  <div class="overview-text3">
                    Let’s consider a different sequence:<br/>

                    <div class="binary">101 101 101 101 101 101 101 101 101 101 101 101 101 101 101 101 101 101</div>
                    
                    Visualizing this sequence, we have the following game configuration:<br/>

                    <img style="display: block; margin: 0 auto;" class="jenga-tower-cropped" src="images/mtgm-tower-1.png" />

                    This would be considered a “<b>success state</b>” because this tower is structurally sound and would not collapse.<br/>
                    Let’s consider another sequence:<br/>

                    <div class="binary">010 010 010 010 010 010 010 010 010 010 010 010 010 010 010 010 010 010</div>

                    If we were to visualize the above sequence:<br/>

                    <img style="display: block; margin: 0 auto;" class="jenga-tower-cropped" src="images/mtgm-tower-2.png" />

                    Similar to the previous configuration, this would also be considered a “success state” because this tower is structurally sound and would not collapse.<br/>
                    On the other hand, if we were to visualize a sequence like:<br/>

                    <div class="binary">111 111 111 000 000 000 111 111 111 000 000 000 111 111 111 000 000 000</div>

                    This would result in the following game configuration:<br/>

                    <img style="display: block; margin: 0 auto;" class="jenga-tower-cropped" src="images/mtgm-tower-3.png" />

                    This would immediately be ruled out as a “<b>fail state</b>” because the tower is (clearly) unstable and would collapse.<br/>
                    Similarly, if we were to visualize a sequence like:<br/>

                    <div class="binary">001 001 100 100 001 001 100 100 001 001 100 100 001 001 100 100 001 001</div>

                    This would result in the following game configuration:<br/>

                    <img style="display: block; margin: 0 auto;" class="jenga-tower-cropped" src="images/mtgm-tower-4.png" />

                    Again, this would be considered a “fail state” because the tower is highly unstable and would collapse.<br/>

                    Although we could simply use the physics engine to determine which states are success and fail states (i.e., whether or not the tower falls over), if we assume that running a single simulation takes 0.1 seconds, this means that simulating all 2<sup>54</sup> possible configurations would take approximately 57,123,283 years (this is unreasonably long!). Thus, we must rely on analysis techniques to eliminate as many fail states as we can.<br/><br/>
                    <span class="overview-text-span3">
                      Eliminating “Fail States” Through Analysis
                      <br />
                    </span>
                    As demonstrated earlier, not all 2<sup>54</sup> of these configurations are physically possible, as some of these combinations would result in floating pieces, or pieces whose center of mass is not supported, immediately constituting a fail state. In order to determine what fraction of these configurations result in fail states, let us reconsider 2 of the above examples:

                    <img style="display: block; margin: 0 auto;" class="jenga-tower-wide" src="images/mtgm-tower-5.png" />

                    On the <b>left</b> is <span class="binary">111 111 111 000 000 000 111 111 111 000 000 000 111 111 111 000 000 000</span>.<br/>
                    On the <b>right</b> is <span class="binary">001 001 100 100 001 001 100 100 001 001 100 100 001 001 100 100 001 001</span>.<br/>

                    A similarity that exists between these two fail configurations is the presence of <b>two or more consecutive zeros within a single tribit</b>. Let’s visualize some more sequences to determine if this is a consistent pattern:<br/>

                    <img style="display: block; margin: 0 auto;" class="jenga-tower-wide2" src="images/mtgm-tower-6.png" />

                  </div>
                </div>
 
                </div>
                





                <div class="page" id="gsvis_page">

                  <div class="jenga-subsection">
                    <span>
                      <span class="overview-text-span">
                        Game-State Visualizer in Scratch
                        <br />
                        <br />
                      </span>
                      <span class="overview-text-span4">
                        Embedded below is a first version of our game-state visualizer, mocked up in <a class="link" href="https://scratch.mit.edu/projects/1038274559" target="_blank">Scratch</a>.<br/>
                        The visualizer accepts a 54-bit binary sequence of 0s and 1s, and visualizes this sequence as a Jenga tower, where 0s are empty spaces and 1s are blocks.<br/>
                        This visualizer was created to aid in our discourse surrounding the development of our eventual Unity game-state simulator, as we did not have access to an actual Jenga set at the time, making it difficult to convey ideas effectively.<br/>
                        This tool can visualize all 2<sup>54</sup> unique configurations of Jenga blocks, including all impossible configurations (i.e., configurations with floating blocks).<br/><br/>

                        It is worth noting that any state that is not <span class="binary">111111111111111111111111111111111111111111111111111111</span> is technically <em>not</em> a valid game state, as all 54 blocks must be in play during an official game of Jenga.<br/><br/>
                        <span class="overview-text-span3">
                          Instructions
                          <br />
                        </span>
                        <div class="jenga-subsection">
                          <div class="overview-text2">
                              <span class="overview-text-2-span5">
                                To use the visualizer, press the green flag button (top left), and enter a 54-bit binary sequence in the text field.<br/>
                        You can try recreating the various sequences detailed in <a class="u-24-mtgm-button" style="color: #ff8aa2; font-weight: bold; padding: 0 0 0 0; background-color:rgba(0, 0, 0, 0);">Modeling the Game Mathematically</a> by copy-pasting the following sequences:<br/>
                        <span class="binary">111111111111111111111111111111111111111111111111111111</span><br/>
                        <span class="binary">101101101101101101101101101101101101101101101101101101</span><br/>
                        <span class="binary">010010010010010010010010010010010010010010010010010010</span><br/>
                        <span class="binary">111111111000000000111111111000000000111111111000000000</span><br/>
                        <span class="binary">001001100100001001100100001001100100001001100100001001</span><br/>                        
                        <span class="binary">111111111111111111111111111111111111111111111111111100</span><br/> 
                              </span>
                          </div>
                          <iframe src="https://scratch.mit.edu/projects/1038274559/embed" allowtransparency="true" width="740" height="430" frameborder="0" scrolling="no" allowfullscreen></iframe>
                        </div>   
                        <span class="overview-text-span3">
                          Feature or Bug? You Decide!
                          <br />
                        </span>
                        This visualizer is quite <b>buggy</b>. If you notice that pieces are stacked incorrectly, restart the visualizer (by clicking the green flag) and input your desired sequence again.
                        
                      </span>
                    </span>
                  </div>
   
                  </div>






                  <div class="page" id="gssv1_page">

                    <div class="jenga-subsection">
                      <span>
                        <span class="overview-text-span">
                          Game-State Simulator V1 in Unity
                          <br />
                          <br />
                        </span>
                        <span class="overview-text-span4">
                          Embedded below is V1 of our <b>Unity Game-State Simulator</b>.<br/>
                          To serve as a basic framework/prototype for our eventual machine-learning program, we created a Jenga game-state simulator that makes use of Unity's built-in physics engine. This simulator allows a user to remove blocks from the tower, watch the outcome of their configuration in real time (by enabling physics), and save/load various configurations of said tower. Additionally, this simulator acts a slightly more sophisticated version of our initial Scratch game-state visualizer.<br/><br/>
  
                          <span class="overview-text-span3">
                            Instructions
                            <br />
                          </span>
                          To start the simulator, press <b>Launch Simulator (V1)</b>.<br/>
                          When the simulation starts, select blocks to remove them from the tower.<br/>
                          When you're ready, press the <b>Start Button</b> to toggle gravity, and watch the chaos unfold.<br/>
                          <span class="overview-text-span3">
                            Controls
                            <br />
                          </span>
                          <div style="display: flex; flex-direction: row; align-items: center; padding: 5px;">
                            <img src="https://raw.githubusercontent.com/move-master/MoveMaster/refs/heads/main/MoveMaster_UnityProject_V2/Assets/Materials/status_ok_tex.png" style="width:5vh;height:5vh;"></img> 
                            <div style="padding-left: 1vh;">Status Indicator (Check or Cross)</div>
                          </div>

                          <div style="display: flex; flex-direction: row; align-items: center; padding: 5px;">
                            <img src="https://raw.githubusercontent.com/move-master/MoveMaster/refs/heads/main/MoveMaster_UnityProject_V2/Assets/Materials/reset_state_button_tex.png" style="width:5vh;height:5vh;"></img> 
                            <div style="padding-left: 1vh;">Reset Tower</div>
                          </div>

                          <div style="display: flex; flex-direction: row; align-items: center; padding: 5px;">
                            <img src="https://raw.githubusercontent.com/move-master/MoveMaster/refs/heads/main/MoveMaster_UnityProject_V2/Assets/Materials/save_state_button_tex.png" style="width:5vh;height:5vh;"></img> 
                            <div style="padding-left: 1vh;">Save Current Tower Configuration</div>
                          </div>

                          <div style="display: flex; flex-direction: row; align-items: center; padding: 5px;">
                            <img src="https://raw.githubusercontent.com/move-master/MoveMaster/refs/heads/main/MoveMaster_UnityProject_V2/Assets/Materials/play_button_tex.png" style="width:5vh;height:5vh;"></img> 
                            <div style="padding-left: 1vh;">Start/Stop Simulation (Toggle Gravity)</div>
                          </div>

                          <div style="display: flex; flex-direction: row; align-items: center; padding: 5px;">
                            <img src="https://raw.githubusercontent.com/move-master/MoveMaster/refs/heads/main/MoveMaster_UnityProject_V2/Assets/Materials/change_view_button_tex.png" style="width:5vh;height:5vh;"></img> 
                            <div style="padding-left: 1vh;">Change Viewing Angle</div>
                          </div>
                          <div class="jenga-subsection">
                            
                            
                            <button id="loadGame" style="background-color: rgb(74, 191, 187); font-family: 'Inter-Regular', sans-serif; padding: 10px; border-radius: 5px; ">Launch Simulator <b>(V1)</b></button>
    
                            <div id="iframeContainer"></div> <!-- This is where the iframe will be added -->

                            <script>
                                const loadButton = document.getElementById("loadGame");
                                const unloadButtons = document.querySelectorAll(".unloadButton"); // Select all elements with the "unloadButton" class
                                const container = document.getElementById("iframeContainer");

                                loadButton.addEventListener("click", function() {
                                    $(this).hide();
                                    if (!container.querySelector("iframe")) { // Only add if it's not already loaded
                                        const iframe = document.createElement("iframe");
                                        iframe.src = "/MoveMaster_WEBGL_build_V4/"; // Your game URL
                                        iframe.width = "1000";
                                        iframe.height = "800";
                                        iframe.frameBorder = "3"; // Set the frame border
                                        iframe.style.border = "none"; // Set iframe border style
                                        iframe.allowFullscreen = true;
                                        container.appendChild(iframe);
                                    }
                                });

                                // Loop through all unloadButton elements and add the event listener to each
                                unloadButtons.forEach(function(button) {
                                    button.addEventListener("click", function() {
                                        $("#loadGame").show();
                                        container.innerHTML = ""; // Removes the iframe
                                    });
                                });
                            </script>

                          </div>   
                          <span class="overview-text-span3">
                            Not All Bugs Are Bad – Some Are Features
                            <br />
                          </span>
                          Not unlike our Scratch visualizer, Version 1 of our game-state simulator is <b>also quite buggy</b>. If you notice that the Save State button doesn't save the state properly, or the indicator stops indicating properly, restart the simulation (reload the page) and try again.
                          
                        </span>
                      </span>
                    </div>
     
                    </div>




               

             </div>
           </div>
         </div>
       </div>    
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="util.js"></script>   
   </body>
</html>